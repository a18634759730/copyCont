##栈stack和堆heap

    栈内存上分配的内存系统自动释放 
    堆内存上分配的内存系统不释放哪怕程序退出那一块内存还是在那里
    栈内存一般是静态分配内存
    堆内存上一般是动态分配内存

## 栈内存

    *基本类型:存放在栈内存中的简单数据段,数据大小确定,内存空间大小可以分配 

    *5种基本数据类型有 
        undefined 
        null 
        Boolean 
        Number 
        String 
    它们是直接按值存放的所以可以直接访问

## 堆内存

    *引用类型:存放在堆内存中的对象变量中实际保存的是一个指针,这个指针指向另一个位置
    每个空间大小不一样要根据情况开进行特定的分配

    *当访问引用类型 对象 数组 函数的值时 首先从栈中获得该对象的地址指针 然后再从堆内存中取得所需的数据
 
    let a1 = 0; // 栈内存
    let a2 = "this is string" // 栈内存
    let a3 = null; // 栈内存
    let b = { x: 10 }; // 变量b存在于栈中，{ x: 10 }作为对象存在于堆中
    let c = [1, 2, 3]; // 变量c存在于栈中，[1, 2, 3]作为对象存在于堆中 
 
 
## 浅拷贝
    在定义一个对象或数组时 变量存放的往往只是一个地址，当我们使用对象拷贝时 如果属性是对象或数组时这时候我们传递的也只是一个地址因此子对象在访问该属性时，会根据地址回溯到父对象指向的堆内存中，即父子对象发生了关联，两者的属性值会指向同一内存空间

    var a = {
        key1:"11111"
    }
    function Copy(p) {
        var c = {};
        for (var i in p) { 
        　　 c[i] = p[i];
        }
        return c;
    }
    a.key2 = ['小辉','小辉'];
    var b = Copy(a);
    b.key3 = '33333';
    alert(b.key1);     //1111111
    alert(b.key3);    //33333
    alert(a.key3);    //undefined

## 深拷贝

    不希望父子对象之间产生关联 可以用到深拷贝 属性值类型是数组和或象时只会传值就用递归来解决这个问题，把父对象中所有属于对象的属性类型都遍历赋给子对象即可
 
    function Copy(p, c) {
    var c = c || {};
    for (var i in p) {
    　　 if (typeof p[i] === 'object') {
                c[i] = (p[i].constructor === Array) ? [] : {};
                Copy(p[i], c[i]);
    　　 } else {
                c[i] = p[i];
    　　 }
    }
    return c;
    }
    a.key2 = ['小辉','小辉'];
    var b={};
    b = Copy(a,b);        
    b.key2.push("大辉");
    alert(b.key2);    //小辉，小辉，大辉
    alert(a.key2);    //小辉，小辉
 